=== tests/cases/conformance/expressions/typeGuards/typeGuardsInIfStatement.ts ===
// Type guards are particular expression patterns involving the �typeof� and �instanceof� operators 
// that cause the types of variables or parameters to be narrowed to more specific types.

function foo(x: number | string) {
>foo : (x: string | number) => number
>x : string | number

    // In the true branch statement of an �if� statement, 
    // the type of a variable or parameter is narrowed by any type guard in the �if� condition when true, 
    // provided the true branch statement contains no assignments to the variable or parameter.
    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        return x.length; // string
>x.length : number
>x : string
>length : number
    }
    else {
        // In the false branch statement of an �if� statement, 
        // the type of a variable or parameter is narrowed by any type guard in the �if� condition when false, 
        // provided the false branch statement contains no assignments to the variable or parameter
        return x++; // number
>x++ : number
>x : number
    }
}
function foo2(x: number | string) {
>foo2 : (x: string | number) => string | number
>x : string | number

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        // x is used in the if true branch, the type is not narrowed
        x = 10;
>x = 10 : number
>x : string | number

        return x; // string | number
>x : string | number
    }
    else {
        return x++; // number
>x++ : number
>x : number
    }
}
function foo3(x: number | string) {
>foo3 : (x: string | number) => string | number
>x : string | number

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        // x is used in the if true branch, the type is not narrowed
        x = "Hello"; // even though assigned using same type as narrowed expression
>x = "Hello" : string
>x : string | number

        return x; // string | number
>x : string | number
    }
    else {
        return x++; // number
>x++ : number
>x : number
    }
}
function foo4(x: number | string) {
>foo4 : (x: string | number) => string | number
>x : string | number

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        return x.length; // string
>x.length : number
>x : string
>length : number
    }
    else {
        // false branch updates the variable - so here it is not number
        x = 10; // even though assigned number - this should result in x to be string | number
>x = 10 : number
>x : string | number

        return x; // string | number
>x : string | number
    }
}
function foo5(x: number | string) {
>foo5 : (x: string | number) => string | number
>x : string | number

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        return x.length; // string
>x.length : number
>x : string
>length : number
    }
    else {
        // false branch updates the variable - so here it is not number
        x = "hello";
>x = "hello" : string
>x : string | number

        return x; // string | number
>x : string | number
    }
}
function foo6(x: number | string) {
>foo6 : (x: string | number) => string | number
>x : string | number

    // Modify in both branches
    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        x = 10;
>x = 10 : number
>x : string | number

        return x; // string | number
>x : string | number
    }
    else {
        x = "hello";
>x = "hello" : string
>x : string | number

        return x; // string | number
>x : string | number
    }
}
function foo7(x: number | string | boolean) {
>foo7 : (x: string | number | boolean) => boolean
>x : string | number | boolean

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number | boolean

        return x === "hello"; // string
>x === "hello" : boolean
>x : string
    }
    else if (typeof x === "boolean") {
>typeof x === "boolean" : boolean
>typeof x : string
>x : number | boolean

        return x; // boolean
>x : boolean
    }
    else {
        return x == 10; // number
>x == 10 : boolean
>x : number
    }
}
function foo8(x: number | string | boolean) {
>foo8 : (x: string | number | boolean) => boolean
>x : string | number | boolean

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number | boolean

        return x === "hello"; // string
>x === "hello" : boolean
>x : string
    }
    else {
        var b: number | boolean = x; //  number | boolean
>b : number | boolean
>x : number | boolean

        if (typeof x === "boolean") {
>typeof x === "boolean" : boolean
>typeof x : string
>x : number | boolean

            return x; // boolean
>x : boolean
        }
        else {
            return x == 10; // number
>x == 10 : boolean
>x : number
        }
    }
}
function foo9(x: number | string) {
>foo9 : (x: string | number) => boolean
>x : string | number

    var y = 10;
>y : number

    if (typeof x === "string") {
>typeof x === "string" : boolean
>typeof x : string
>x : string | number

        y = x.length; // usage of x or assignment to separate variable shouldn't cause narrowing of type to stop
>y = x.length : number
>y : number
>x.length : number
>x : string
>length : number

        return x === "hello"; // string
>x === "hello" : boolean
>x : string
    }
    else {
        return x == 10; // number
>x == 10 : boolean
>x : number
    }
}
